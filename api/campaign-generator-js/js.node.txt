// Depending on your Node.js version and environment (e.g., Next.js 12+, Vercel Edge),
// native fetch may be available, and this import might not be necessary.
import fetch from 'node-fetch';

/**
 * API handler to generate a social media campaign using the Gemini API.
 * @param {object} request - The incoming request object.
 * @param {object} response - The outgoing response object.
 */
export default async function handler(request, response) {
    // 1. Ensure the request method is POST
    if (request.method !== 'POST') {
        response.setHeader('Allow', ['POST']);
        return response.status(405).json({ error: 'Method Not Allowed' });
    }

    try {
        // 2. Extract and validate data from the request body
        const { productName, platforms, imageData, imageType } = request.body;

        if (!productName || !platforms || !Array.isArray(platforms) || platforms.length === 0) {
            return response.status(400).json({ error: 'Missing required fields: productName and platforms are required.' });
        }

        // 3. Get the API key from environment variables
        const apiKey = process.env.GEMINI_API_KEY;
        if (!apiKey) {
            console.error('GEMINI_API_KEY is not set in environment variables.');
            return response.status(500).json({ error: 'Server-side API key is not configured.' });
        }

        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        // 4. Construct the prompt and payload for the Gemini API
        // This prompt is tailored to your goal of highlighting scientific and botanical benefits.
        const basePrompt = `Create a social media campaign for the following platforms: ${platforms.join(', ')}. For each platform, provide a "headline", "ad_copy", "visual_concept", and "call_to_action". Focus on highlighting the scientific and botanical benefits of the product. Format as a single JSON array of objects. Each object in the array should represent a platform and contain the keys "platform_name", "headline", "ad_copy", "visual_concept", and "call_to_action".`;

        const payload = {
            contents: [{ role: "user", parts: [] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "platform_name": { "type": "STRING" },
                            "headline": { "type": "STRING" },
                            "ad_copy": { "type": "STRING" },
                            "visual_concept": { "type": "STRING" },
                            "call_to_action": { "type": "STRING" }
                        },
                        required: ["platform_name", "headline", "ad_copy", "visual_concept", "call_to_action"]
                    }
                }
            }
        };

        // Conditionally add image data or just use the product name
        let campaignPrompt;
        if (imageData && imageType) {
            campaignPrompt = `Based on the image of a ${productName}, ${basePrompt}`;
            payload.contents[0].parts.push({ text: campaignPrompt });
            payload.contents[0].parts.push({ inlineData: { mimeType: imageType, data: imageData } });
        } else {
            campaignPrompt = `Create a campaign for a product called "${productName}". ${basePrompt}`;
            payload.contents[0].parts.push({ text: campaignPrompt });
        }

        // 5. Make the API call to Gemini
        const geminiResponse = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        // 6. Handle non-successful API responses
        if (!geminiResponse.ok) {
            const errorBody = await geminiResponse.text();
            console.error(`Gemini API Error: ${geminiResponse.status} ${geminiResponse.statusText}`, errorBody);
            throw new Error(`Campaign generation failed. Status: ${geminiResponse.status}`);
        }

        // 7. Process the successful response
        const result = await geminiResponse.json();
        const candidate = result.candidates?.[0];
        const textResponse = candidate?.content?.parts?.[0]?.text;

        if (!textResponse) {
            console.error("Invalid response structure from Gemini API:", JSON.stringify(result, null, 2));
            throw new Error("Invalid response from API. Text content missing.");
        }

        // 8. Safely parse the JSON response from the model and send it to the client
        try {
            const campaignData = JSON.parse(textResponse);
            return response.status(200).json(campaignData);
        } catch (parseError) {
            console.error("Failed to parse JSON response from Gemini:", textResponse);
            throw new Error("The generated campaign content was not valid JSON.");
        }

    } catch (error) {
        // 9. Generic error handler for any other issues
        console.error('An unexpected error occurred:', error);
        // Avoid leaking implementation details in the error message to the client
        const errorMessage = error instanceof Error ? error.message : 'An internal server error occurred.';
        return response.status(500).json({ error: errorMessage });
    }
}

